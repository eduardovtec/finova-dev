<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rastreador de Mercado - Finova</title>
    <link rel="icon" type="image/png" href="Images/favicon.png">
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        .dashboard-container {
            min-height: calc(100vh - 80px);
            height: calc(100vh - 80px);
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            margin: 0;
            padding: 0;
        }
        .content-wrapper {
            flex: 1 1 auto;
            display: flex;
            flex-direction: column;
            margin: 0;
            padding: 20px;
        }
        .card {
            background: rgba(255,255,255,0.70);
            backdrop-filter: blur(8px) saturate(160%);
            -webkit-backdrop-filter: blur(8px) saturate(160%);
            border-radius: 24px;
            box-shadow: 0 8px 32px 0 rgba(0, 102, 204, 0.10), 0 1.5px 8px 0 rgba(0,0,0,0.07);
            padding: 32px 28px 28px 28px;
            margin-bottom: 32px;
            border: 1.5px solid rgba(0, 102, 204, 0.08);
            transition: box-shadow 0.25s, transform 0.18s;
        }
        .card:hover {
            box-shadow: 0 16px 48px 0 rgba(0, 102, 204, 0.18), 0 2px 12px 0 rgba(0,0,0,0.10);
            transform: translateY(-4px) scale(1.012);
        }
        .sidebar {
            position: fixed;
            left: 0;
            top: 80px;
            bottom: 0;
            width: 250px;
            background: var(--primary-color);
            color: white;
            padding: 20px 0;
            overflow-y: auto;
            z-index: 100;
            transition: all 0.3s ease;
        }
        .sidebar-header {
            padding: 0 20px 20px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .sidebar-header h3 {
            margin: 0;
            font-size: 1.2rem;
        }
        .sidebar-header p {
            margin: 5px 0 0;
            font-size: 0.9rem;
            opacity: 0.7;
        }
        .menu-items {
            padding: 15px 0;
        }
        .menu-item {
            padding: 10px 20px;
            display: flex;
            align-items: center;
            color: rgba(255,255,255,0.8);
            transition: all 0.3s;
            text-decoration: none;
        }
        .menu-item:hover, .menu-item.active {
            background: rgba(255,255,255,0.1);
            color: white;
        }
        .menu-item i {
            margin-right: 10px;
            width: 20px;
            text-align: center;
        }
        .content-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .content-header h1 {
            color: var(--primary-color);
            margin: 0;
        }
        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .card-header h2 {
            color: var(--primary-color);
            margin: 0;
            font-size: 1.3rem;
        }
        .period-title, .card-header h2 {
            display: flex;
            align-items: center;
        }
        .info-icon {
            margin-left: 8px;
            font-size: 1rem;
            color: #666;
            cursor: help;
            position: relative;
        }
        .tooltip-box {
            display: none;
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 12px;
            border-radius: 8px;
            width: 250px;
            text-align: center;
            font-size: 0.9rem;
            line-height: 1.4;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .info-icon:hover .tooltip-box {
            display: block;
            opacity: 1;
        }
        .tooltip-box::before {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border-width: 8px;
            border-style: solid;
            border-color: transparent transparent rgba(0, 0, 0, 0.85) transparent;
        }
        .navbar {
            background: white;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
        }
        .toggle-sidebar {
            display: none;
            background: none;
            border: none;
            color: var(--primary-color);
            font-size: 1.5rem;
            cursor: pointer;
        }
        .user-menu {
            position: relative;
        }
        .user-menu-trigger {
            display: flex;
            align-items: center;
            cursor: pointer;
        }
        .user-menu-trigger img {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            object-fit: cover;
            margin-right: 10px;
        }
        .user-menu-content {
            position: absolute;
            top: 100%;
            right: 0;
            background: white;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            border-radius: 10px;
            width: 200px;
            padding: 10px 0;
            display: none;
            z-index: 1000;
        }
        .user-menu-content.show {
            display: block;
        }
        .user-menu-item {
            padding: 10px 20px;
            display: block;
            color: #333;
            transition: all 0.3s;
        }
        .user-menu-item:hover {
            background: #f5f5f5;
        }
        .user-menu-separator {
            height: 1px;
            background: #eee;
            margin: 5px 0;
        }
        /* Estilos para o rastreador de mercado */
        .chart-container {
            background: white;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            padding: 20px;
            height: 400px;
            margin-bottom: 25px;
        }
        .market-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 20px;
            margin-bottom: 25px;
        }
        .stat-card {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        .stat-title {
            color: #666;
            font-size: 0.9rem;
            margin-bottom: 10px;
        }
        .stat-value {
            font-size: 1.8rem;
            font-weight: 600;
            color: var(--primary-color);
        }
        .change {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-top: 5px;
        }
        .positive {
            color: #00c853;
        }
        .negative {
            color: #f44336;
        }
        .market-table {
            width: 100%;
            border-collapse: collapse;
        }
        .market-table th,
        .market-table td {
            padding: 12px 15px;
            text-align: left;
        }
        .market-table th {
            background-color: #f5f9ff;
            color: var(--primary-color);
        }
        .market-table tbody tr:hover {
            background-color: #f5f9ff;
        }
        @media (max-width: 992px) {
            .sidebar {
                transform: translateX(-100%);
            }
            .content-wrapper {
                margin-left: 0;
            }
            .sidebar.show {
                transform: translateX(0);
            }
            .toggle-sidebar {
                display: block;
            }
        }
        #excel-graph-section {
    background: white;
    border-radius: 15px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    padding: 25px 20px 20px 20px;
    margin-bottom: 30px;
    color: var(--primary-color);
}
#excel-graph-section label, #excel-graph-section select {
    font-family: 'Poppins', sans-serif;
    font-size: 1rem;
    color: #333;
    font-weight: 500;
}
#excel-graph-section select {
    padding: 8px 12px;
    border-radius: 8px;
    border: 1px solid #e0e0e0;
    background-color: #fff;
    outline: none;
}
#excel-graph-section select:focus {
    border-color: var(--primary-color);
    box-shadow: 0 0 0 2px rgba(var(--primary-color-rgb), 0.2);
}
#chartPeriod {
    background: transparent;
    min-height: 350px;
    max-height: 420px;
    width: 100%;
}
.period-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 15px;
    gap: 20px;
}
.period-title {
    font-weight: 600;
    font-size: 1.2rem;
    color: var(--primary-color);
}
        #chartPeriod {
            background: transparent;
            min-height: 350px;
            max-height: 420px;
        }
        #chartIndex {
            background: transparent;
            min-height: 350px;
            max-height: 420px;
            width: 100%;
        }
        
        /* Regra padr√£o - mostrar desktop por padr√£o */
        .card-momento-desktop {
            display: block !important;
        }
        .card-momento-mobile {
            display: none !important;
        }
        
        @media (max-width: 768px) {
            #chartPeriod {
                display: none !important;
            }
                          .mobile-chart-container {
                  display: block !important;
              }
              #chartPeriodMobile {
                  display: block !important;
                  touch-action: none !important;
                  max-height: 350px !important;
                  border-radius: 12px;
                  box-shadow: 0 2px 8px rgba(0,0,0,0.05);
              }


            .card {
                padding: 15px;
                margin-bottom: 20px;
            }
            .period-header {
                margin-bottom: 15px;
            }
            .period-title {
                font-size: 1.1rem;
            }
            .card-momento-desktop {
                display: none !important;
            }
            .card-momento-mobile {
                display: block !important;
                background: rgba(255,255,255,0.95);
                backdrop-filter: blur(10px);
                border-radius: 20px;
                box-shadow: 0 8px 32px rgba(0,0,0,0.1), 0 2px 8px rgba(0,0,0,0.05);
                padding: 20px 15px 15px 15px;
                width: 100%;
                max-width: 100vw;
                border: 1px solid rgba(0,0,0,0.05);
                transition: all 0.3s ease;
            }
            .card-momento-mobile:hover {
                transform: translateY(-2px);
                box-shadow: 0 12px 40px rgba(0,0,0,0.15), 0 4px 12px rgba(0,0,0,0.08);
            }
            #periodSelectMobile:hover {
                border-color: var(--primary-color);
                box-shadow: 0 4px 12px rgba(0,102,204,0.15);
            }
            #periodSelectMobile:focus {
                border-color: var(--primary-color);
                box-shadow: 0 0 0 3px rgba(0,102,204,0.1);
            }
        }
        @media (min-width: 769px) {
            .card-momento-desktop {
                display: block !important;
            }
            .card-momento-mobile {
                display: none !important;
            }
            #chartPeriodPreviewMobile, #modalFullChart {
                display: none !important;
            }
        }
        #modalFullChart {
            display: none;
        }
        #modalFullChart.active {
            display: flex !important;
        }
        
        /* Estilos para os filtros de data */
        .date-filters {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: flex-end;
            max-width: 100%;
            overflow: hidden;
        }
        
        .filter-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .filter-btn, .filter-btn-ibov {
            padding: 8px 16px;
            border: 1px solid #ddd;
            border-radius: 20px;
            background: white;
            color: #666;
            font-family: 'Poppins', sans-serif;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
        }
        
        .filter-btn:hover, .filter-btn-ibov:hover {
            background: #f0f8ff;
            border-color: var(--primary-color);
            color: var(--primary-color);
        }
        
        .filter-btn.active, .filter-btn-ibov.active {
            background: var(--primary-color);
            border-color: var(--primary-color);
            color: white;
        }
        
        .custom-date-range {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 5px;
            max-width: 100%;
            flex-wrap: wrap;
            justify-content: flex-end;
        }
        
        .custom-date-range input[type="date"] {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-family: 'Poppins', sans-serif;
            font-size: 0.9rem;
            color: #666;
        }
        
        .apply-btn {
            padding: 8px 16px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 8px;
            font-family: 'Poppins', sans-serif;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.3s ease;
        }
        
        .apply-btn:hover {
            background: #005aa3;
        }
        
        @media (max-width: 768px) {
            .period-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 15px;
            }
            
            .date-filters {
                align-items: stretch;
                width: 100%;
            }
            
            .filter-buttons {
                justify-content: space-between;
                flex-wrap: wrap;
            }
            
            .filter-btn, .filter-btn-ibov {
                flex: 1;
                text-align: center;
                padding: 6px 8px;
                font-size: 0.8rem;
                min-width: 60px;
            }
            
            .custom-date-range {
                flex-direction: column;
                gap: 8px;
                width: 100%;
                justify-content: stretch;
            }
            
            .custom-date-range input[type="date"] {
                width: 100%;
                box-sizing: border-box;
            }
            
            .apply-btn {
                width: 100%;
            }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
</head>
<body>
    <!-- Navega√ß√£o -->
    <header>
        <nav class="navbar">
            <div class="navbar-left">
                
                <div class="logo">
                    <a href="dashboard.html">
                        <img src="Images/Logo.png" alt="Finova Logo">
                    </a>
                </div>
            </div>
            
        </nav>
    </header>
    <!-- Conte√∫do Principal -->
    <div class="dashboard-container">
        <div class="content-wrapper">
            <div class="content-header">
                <h1>Rastreador de Mercado</h1>
            </div>
            <!-- Sobre o Rastreador -->
            <div class="card">
                <div class="card-header">
                    <h2>Sobre o Rastreador</h2>
                </div>
                <div style="line-height: 1.6; color: #444;">
                    <p style="margin-bottom: 1.5em;">O conceito principal por tr√°s do Rastreador √© simples: m√©dias m√≥veis. Mas o uso aqui √© bem diferente do tradicional no mercado financeiro.</p>
                    <p style="margin-bottom: 1.5em;">No nosso caso, usamos esse conceito para rastrear o comportamento do mercado como um todo, n√£o apenas de uma a√ß√£o isolada.</p>
                    <p>Para conhecer a metodologia completa e aproveitar ao m√°ximo o Rastreador de Mercado, acesse a √°rea de <a href="analysis.html" style="color: var(--primary-color); text-decoration: none; font-weight: 500;">An√°lises</a>.</p>
                </div>
            </div>
            <!-- Novo Card Momento de Mercado (MOBILE) -->
            <div class="card-momento-mobile" style="display:none; margin-bottom: 20px;">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;">
                    <span style="font-weight:600;font-size:1.1rem;color:var(--primary-color);">Momento de Mercado</span>
                    <select id="periodSelectMobile" style="padding: 8px 12px; border-radius: 12px; border: 1px solid rgba(0,0,0,0.1); background-color: rgba(255,255,255,0.9); outline: none; font-family: 'Poppins', sans-serif; font-size: 0.95rem; color: #333; font-weight: 500; box-shadow: 0 2px 8px rgba(0,0,0,0.05); transition: all 0.2s ease;">
                        <option value="21">Curt√≠ssimo Prazo</option>
                        <option value="62">Curto Prazo</option>
                        <option value="125">M√©dio Prazo</option>
                        <option value="252">Longo Prazo</option>
                    </select>
                </div>
                <div id="mobile-momento-chart" style="width:100%;display:flex;flex-direction:column;align-items:center;justify-content:center;padding:10px 0 0 0;"></div>
                <div id="mobile-momento-media" style="text-align:center;font-size:1.1rem;font-weight:500;margin-top:8px;color:#888;display:none;"></div>
                <div id="mobile-momento-label" style="text-align:center;font-size:1.1rem;font-weight:500;margin-top:8px;"></div>
                <div id="mobile-momento-update" style="text-align:center;font-size:0.95rem;color:#888;margin-top:8px;"></div>
            </div>
            <!-- Card Momento de Mercado (DESKTOP) -->
            <div class="card card-momento-desktop" style="margin-bottom: 30px;">
                <div class="card-header" style="display: flex; justify-content: space-between; align-items: center;">
                    <h2>Momento de Mercado
                        <span class="info-icon">
                            <i class="fas fa-question-circle"></i>
                            <span class="tooltip-box">O indicador "Momento de Mercado" mostra a condi√ß√£o atual do mercado em uma escala de 0 a 100. Quando o indicador est√° entre 0-10 (Sobrevenda Extrema), √© uma oportunidade √∫nica de entrada. Entre 10-20 (Sobrevenda), representa uma boa oportunidade de entrada. Entre 20-80 (Neutro), o mercado est√° em equil√≠brio. Entre 80-90 (Sobrecompra), √© necess√°rio ter cautela com novas entradas. Entre 90-100 (Sobrecompra Extrema), √© recomendado evitar novas entradas. A bolinha tracejada mostra a m√©dia dos diferentes per√≠odos.</span>
                        </span>
                    </h2>
                    <div>
                        <label for="periodSelect" style="margin-right: 10px; font-family: 'Poppins', sans-serif; font-size: 1rem; color: #333; font-weight: 500;">Per√≠odo:</label>
                        <select id="periodSelect" style="padding: 8px 12px; border-radius: 8px; border: 1px solid #e0e0e0; background-color: #fff; outline: none; font-family: 'Poppins', sans-serif; font-size: 1rem; color: #333; font-weight: 500;">
                            <option value="21">Curt√≠ssimo Prazo</option>
                            <option value="62">Curto Prazo</option>
                            <option value="125">M√©dio Prazo</option>
                            <option value="252">Longo Prazo</option>
                        </select>
                    </div>
                </div>
                <div style="display: flex; flex-direction: column; align-items: center; padding: 30px 20px;">
                    <div style="position: relative; width: 100%; height: 140px;">
                        <div style="position: relative; width: 100%; height: 10px; background: #f0f0f0; border-radius: 5px;">
                            <div id="progressBar" style="position: absolute; height: 100%; background: #4CAF50; border-radius: 5px; width: 0%; transition: width 0.5s ease;"></div>
                            <div id="indicator" style="position: absolute; width: 3px; height: 24px; background: #333; top: -7px; left: 0%; transition: left 0.5s ease;"></div>
                            <div id="indicatorCircle" style="position: absolute; width: 70px; height: 70px; background: white; border-radius: 50%; box-shadow: 0 2px 10px rgba(0,0,0,0.1); top: -30px; left: 0%; transform: translateX(-50%); transition: left 0.5s ease; display: flex; align-items: center; justify-content: center;"></div>
                            <div id="indicatorCircleMedia" style="position: absolute; width: 70px; height: 70px; background: white; border-radius: 50%; box-shadow: 0 2px 10px rgba(0,0,0,0.08); top: -30px; left: 0%; transform: translateX(-50%); transition: left 0.5s ease; display: flex; align-items: center; justify-content: center; border: 2px dashed #888; z-index: 1;"></div>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-top: 10px;">
                            <span style="color: #E53935; font-weight: 500;">Sobrevenda<br>Extrema</span>
                            <span style="color: #FF9800; font-weight: 500;">Sobrevenda</span>
                            <span style="color: #FFEB3B; font-weight: 500;">Neutro</span>
                            <span style="color: #4CAF50; font-weight: 500;">Sobrecompra</span>
                            <span style="color: #8BC34A; font-weight: 500;">Sobrecompra<br>Extrema</span>
                        </div>
                        <div id="statusDescription" style="text-align: center; margin-top: 40px; padding: 0 20px; font-size: 18px; line-height: 1.5; color: #666;">
                            O mercado est√° em um estado neutro, indicando equil√≠brio entre compradores e vendedores.
                        </div>
                        <div style="text-align: right; font-size: 13px; color: #888; margin-top: 4px;">Bolinha tracejada: m√©dia dos per√≠odos</div>
                        <div id="lastUpdateLabelMomento" style="text-align: right; margin-top: 8px; font-size: 13px; color: #888;"></div>
                    </div>
                </div>
            </div>
            <!-- Se√ß√£o de sele√ß√£o de per√≠odo para gr√°fico -->
            
            <!-- Se√ß√£o do gr√°fico do Ibovespa/S&P 500 -->
            <div class="card" style="margin-bottom: 30px;">
                
            </div>
        </div>
    </div>
    <!-- Bibliotecas para gr√°ficos e leitura de CSV -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@4.1.1/dist/chartjs-plugin-annotation.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@3.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8/hammer.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script type="module" src="js/global-scripts.js"></script>
    <!-- Registrar plugins globalmente -->
    <script>
        // Aguardar que todos os plugins sejam carregados
        window.addEventListener('load', function() {
            // Verificar se o plugin zoom est√° dispon√≠vel
            if (typeof window.ChartZoom !== 'undefined') {
                Chart.register(window.ChartZoom.default || window.ChartZoom);
                console.log('Plugin zoom registrado com sucesso');
            } else {
                console.log('Plugin zoom ser√° registrado automaticamente');
            }
        });
    </script>
    <!-- Script espec√≠fico para mobile -->
    <script src="js/market-tracker-mobile.js"></script>
    <script>
        // Verifica se √© um dispositivo m√≥vel
        function isMobile() {
            return window.innerWidth <= 768;
        }
        
        const PERIOD_COLUMNS_NAMES = ["21", "62", "125", "252"];
        let csvData = null;
        let ibovData = null;
        let chartInstance = null;
        let indexChartInstance = null;
        let logoImage = new Image();
        logoImage.src = 'Images/Logo.png';
        
        // Vari√°veis para controle dos filtros
        let currentFilter = 'ytd';
        let currentFilterIbov = 'ytd';
        let customStartDate = null;
        let customEndDate = null;
        let customStartDateIbov = null;
        let customEndDateIbov = null;
        
        // Vari√°vel para o gr√°fico mobile
        let mobileChartInstance = null;

        // Fun√ß√£o para criar gr√°fico mobile com zoom e pan
        function createMobileChart() {
            if (!isMobile() || !csvData) return;
            
            const canvas = document.getElementById('chartPeriodMobile');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            
            // Destruir gr√°fico existente se houver
            if (mobileChartInstance) {
                mobileChartInstance.destroy();
                mobileChartInstance = null;
            }
            
            const periodColName = document.getElementById('periodSelectMobile')?.value || '21';
            
            // Aplicar filtro de data
            const filteredData = filterDataByDate(csvData, currentFilter, customStartDate, customEndDate);
            
            const yValues = [];
            const xLabels = [];
            
            filteredData.forEach((row) => {
                const yVal = row[periodColName];
                const dateVal = row['Date'] || row['date'] || row['DATA'] || row['data'] || row['Data'];
                if (yVal !== undefined && yVal !== null && yVal !== "" && !isNaN(parseFloat(yVal))) {
                    yValues.push(parseFloat(yVal));
                    // Converter para formato brasileiro se necess√°rio
                    let formattedDate = dateVal;
                    if (/^\d{4}-\d{2}-\d{2}$/.test(dateVal)) {
                        const [yyyy, mm, dd] = dateVal.split('-');
                        formattedDate = `${dd}/${mm}/${yyyy}`;
                    }
                    xLabels.push(formattedDate);
                }
            });
            
            if (yValues.length === 0) {
                console.warn('Nenhum dado para criar gr√°fico mobile');
                return;
            }
            
            // Calcular os √≠ndices do primeiro ponto de cada ano
            const primeirosAnos = {};
            xLabels.forEach((label, idx) => {
                if (typeof label === 'string' && label.includes('/')) {
                    const [,, year] = label.split('/');
                    if (!(year in primeirosAnos)) {
                        primeirosAnos[year] = idx;
                    }
                }
            });
            
            const gradientLine = ctx.createLinearGradient(0, 0, ctx.canvas.width, 0);
            gradientLine.addColorStop(0, 'rgba(0, 122, 255, 1)');
            gradientLine.addColorStop(1, 'rgba(0, 180, 216, 1)');
            
            const chartData = {
                labels: xLabels,
                datasets: [{
                    label: '',
                    data: yValues,
                    fill: false,
                    borderColor: gradientLine,
                    backgroundColor: gradientLine,
                    borderWidth: 2,
                    pointRadius: 0,
                    pointHoverRadius: 4,
                    tension: 0.1
                }]
            };
            
            const options = {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    intersect: false,
                    mode: 'index',
                },
                scales: {
                    y: {
                        beginAtZero: false,
                        min: 0,
                        max: 100,
                        grid: { display: false, drawBorder: false },
                        ticks: { 
                            color: '#666', 
                            font: { family: 'Poppins', size: 10 },
                            stepSize: 20
                        }
                    },
                    x: {
                        grid: { display: false, drawBorder: false },
                        ticks: {
                            color: '#666',
                            font: { family: 'Poppins', size: 9 },
                            maxTicksLimit: 6,
                            callback: function(value, index, values) {
                                try {
                                    const label = this.getLabelForValue(value);
                                    if (typeof label === 'string' && label.includes('/')) {
                                        const [,, year] = label.split('/');
                                        if (primeirosAnos[year] === index) {
                                            return year;
                                        }
                                    }
                                    return '';
                                } catch (error) {
                                    return '';
                                }
                            }
                        }
                    }
                },
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        backgroundColor: 'rgba(255, 255, 255, 0.95)',
                        borderColor: 'rgba(33, 150, 243, 0.8)',
                        borderWidth: 1,
                        titleColor: '#333',
                        bodyColor: '#666',
                        bodyFont: { family: 'Poppins', size: 12 },
                        padding: 8,
                        cornerRadius: 6
                    },
                    zoom: {
                        pan: {
                            enabled: true,
                            mode: 'x',
                            threshold: 10,
                        },
                        zoom: {
                            wheel: {
                                enabled: false, // Desabilitar zoom com roda do mouse
                            },
                            pinch: {
                                enabled: true, // Habilitar zoom com pin√ßa
                            },
                            mode: 'x',
                            speed: 0.1,
                        },
                        limits: {
                            x: {min: 0, max: xLabels.length - 1},
                            y: {min: 0, max: 100}
                        }
                    }
                }
            };
            
            mobileChartInstance = new Chart(ctx, {
                type: 'line',
                data: chartData,
                options: options
            });
            
            // Configurar controles de zoom
            setupMobileZoomControls();
        }
        
        // Fun√ß√£o para configurar gestos touch no gr√°fico mobile
        function setupMobileZoomControls() {
            // Configurar duplo toque para resetar zoom
            if (mobileChartInstance && mobileChartInstance.canvas) {
                mobileChartInstance.canvas.addEventListener('dblclick', function() {
                    mobileChartInstance.resetZoom();
                });
            }
        }

        // Fun√ß√£o para obter as datas dispon√≠veis no CSV
        function getAvailableDateRange(data) {
            console.log('getAvailableDateRange: analisando', data.length, 'registros');
            const dates = data.map(row => parseRowDate(row)).filter(date => date !== null).sort((a, b) => a - b);
            console.log('getAvailableDateRange: encontradas', dates.length, 'datas v√°lidas');
            if (dates.length > 0) {
                console.log('Primeira data:', dates[0].toLocaleDateString('pt-BR'));
                console.log('√öltima data:', dates[dates.length - 1].toLocaleDateString('pt-BR'));
            }
            return {
                firstDate: dates[0],
                lastDate: dates[dates.length - 1]
            };
        }
        
        // Fun√ß√£o para filtrar dados por data
        function filterDataByDate(data, filter, customStart = null, customEnd = null) {
            console.log('filterDataByDate chamada com:', filter);
            if (filter === 'all' || !data || data.length === 0) {
                console.log('Retornando todos os dados (filtro=all ou dados vazios)');
                return data;
            }
            
            // Obter o intervalo de datas dispon√≠veis no CSV
            const availableRange = getAvailableDateRange(data);
            if (!availableRange.firstDate || !availableRange.lastDate) {
                console.warn('N√£o foi poss√≠vel determinar o intervalo de datas dos dados');
                return data;
            }
            
            // Usar a √∫ltima data do CSV como refer√™ncia (ao inv√©s de hoje)
            const lastAvailableDate = availableRange.lastDate;
            let startDate;
            let endDate = lastAvailableDate;
            
            switch (filter) {
                case 'ytd':
                    // Do in√≠cio do ano at√© a √∫ltima data dispon√≠vel
                    startDate = new Date(lastAvailableDate.getFullYear(), 0, 1);
                    break;
                case '1y':
                    // 1 ano antes da √∫ltima data dispon√≠vel
                    startDate = new Date(lastAvailableDate);
                    startDate.setFullYear(lastAvailableDate.getFullYear() - 1);
                    break;
                case '3y':
                    // 3 anos antes da √∫ltima data dispon√≠vel
                    startDate = new Date(lastAvailableDate);
                    startDate.setFullYear(lastAvailableDate.getFullYear() - 3);
                    break;
                case 'custom':
                    if (customStart && customEnd) {
                        startDate = new Date(customStart);
                        endDate = new Date(customEnd);
                        
                        // Validar se as datas personalizadas est√£o dentro do intervalo dispon√≠vel
                        if (startDate < availableRange.firstDate) {
                            console.warn('Data de in√≠cio anterior aos dados dispon√≠veis. Usando primeira data dispon√≠vel.');
                            startDate = availableRange.firstDate;
                        }
                        if (endDate > availableRange.lastDate) {
                            console.warn('Data de fim posterior aos dados dispon√≠veis. Usando √∫ltima data dispon√≠vel.');
                            endDate = availableRange.lastDate;
                        }
                    } else {
                        return data;
                    }
                    break;
                default:
                    return data;
            }
            
            // Garantir que a data de in√≠cio n√£o seja anterior √† primeira data dispon√≠vel
            if (startDate < availableRange.firstDate) {
                startDate = availableRange.firstDate;
            }
            
            console.log(`Filtrando dados de ${startDate.toLocaleDateString('pt-BR')} at√© ${endDate.toLocaleDateString('pt-BR')}`);
            
            const filteredData = data.filter(row => {
                const rowDate = parseRowDate(row);
                return rowDate && rowDate >= startDate && rowDate <= endDate;
            });
            
            console.log(`Resultado: ${filteredData.length} registros de ${data.length} totais`);
            
            if (filteredData.length === 0) {
                console.warn('Nenhum dado encontrado para o per√≠odo selecionado');
                return data; // Retorna todos os dados se o filtro n√£o encontrar nada
            }
            
            return filteredData;
        }
        
        // Fun√ß√£o para converter data da linha para objeto Date
        function parseRowDate(row) {
            const dateStr = row['Date'] || row['date'] || row['DATA'] || row['data'] || row['Data'];
            if (!dateStr || typeof dateStr !== 'string') {
                console.log('parseRowDate: data n√£o encontrada em', Object.keys(row));
                return null;
            }
            
            try {
                // Detectar formato da data
                if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
                    // Formato YYYY-MM-DD
                    return new Date(dateStr + 'T00:00:00');
                } else if (/^\d{1,2}\/\d{1,2}\/\d{4}$/.test(dateStr)) {
                    // Formato MM/DD/YYYY
                    const [month, day, year] = dateStr.split('/');
                    const parsedMonth = parseInt(month, 10);
                    const parsedDay = parseInt(day, 10);
                    const parsedYear = parseInt(year, 10);
                    
                    // Validar se os valores s√£o v√°lidos
                    if (parsedMonth >= 1 && parsedMonth <= 12 && 
                        parsedDay >= 1 && parsedDay <= 31 && 
                        parsedYear >= 1900 && parsedYear <= 2100) {
                        return new Date(parsedYear, parsedMonth - 1, parsedDay);
                    }
                }
                
                // Tentar outros formatos comuns
                const date = new Date(dateStr);
                if (!isNaN(date.getTime())) {
                    return date;
                }
            } catch (error) {
                console.warn(`Erro ao parsear data: ${dateStr}`, error);
            }
            
            return null;
        }
        
        // Fun√ß√£o para inicializar os event listeners dos filtros
        function initializeFilterListeners() {
            // Filtros para Evolu√ß√£o do Mercado
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    console.log('Filtro clicado:', this.dataset.filter);
                    // Remover classe active de todos os bot√µes
                    document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                    // Adicionar classe active ao bot√£o clicado
                    this.classList.add('active');
                    
                    currentFilter = this.dataset.filter;
                    console.log('currentFilter atualizado para:', currentFilter);
                    
                    // Mostrar/esconder campos de data personalizada
                    const customRange = document.getElementById('customDateRange');
                    if (currentFilter === 'custom') {
                        customRange.style.display = 'flex';
                    } else {
                        customRange.style.display = 'none';
                        // Aplicar filtro imediatamente se n√£o for personalizado
                        drawSelectedPeriodChart();
                        // Criar gr√°fico mobile se for dispositivo m√≥vel
                        createMobileChart();
                        // Exibir informa√ß√µes sobre o per√≠odo selecionado
                        showFilterInfo();
                    }
                });
            });
            
            // Bot√£o para aplicar filtro personalizado
            document.getElementById('applyCustomFilter').addEventListener('click', function() {
                customStartDate = document.getElementById('startDate').value;
                customEndDate = document.getElementById('endDate').value;
                
                if (customStartDate && customEndDate) {
                    drawSelectedPeriodChart();
                    createMobileChart();
                    showFilterInfo();
                } else {
                    alert('Por favor, selecione uma data de in√≠cio e fim.');
                }
            });
            
            // Filtros para Evolu√ß√£o do Ibovespa
            document.querySelectorAll('.filter-btn-ibov').forEach(btn => {
                btn.addEventListener('click', function() {
                    // Remover classe active de todos os bot√µes
                    document.querySelectorAll('.filter-btn-ibov').forEach(b => b.classList.remove('active'));
                    // Adicionar classe active ao bot√£o clicado
                    this.classList.add('active');
                    
                    currentFilterIbov = this.dataset.filter;
                    
                    // Mostrar/esconder campos de data personalizada
                    const customRange = document.getElementById('customDateRangeIbov');
                    if (currentFilterIbov === 'custom') {
                        customRange.style.display = 'flex';
                    } else {
                        customRange.style.display = 'none';
                        // Aplicar filtro imediatamente se n√£o for personalizado
                        if (ibovData) {
                            drawIndexChart(ibovData, 'ibov');
                        }
                    }
                });
            });
            
            // Bot√£o para aplicar filtro personalizado do Ibovespa
            document.getElementById('applyCustomFilterIbov').addEventListener('click', function() {
                customStartDateIbov = document.getElementById('startDateIbov').value;
                customEndDateIbov = document.getElementById('endDateIbov').value;
                
                if (customStartDateIbov && customEndDateIbov) {
                    if (ibovData) {
                        drawIndexChart(ibovData, 'ibov');
                    }
                } else {
                    alert('Por favor, selecione uma data de in√≠cio e fim.');
                }
            });
        }
        
        // Fun√ß√£o para exibir informa√ß√µes sobre o filtro aplicado
        function showFilterInfo() {
            if (!csvData || csvData.length === 0) return;
            
            const availableRange = getAvailableDateRange(csvData);
            if (!availableRange.firstDate || !availableRange.lastDate) return;
            
            let message = '';
            const lastDate = availableRange.lastDate;
            
            switch (currentFilter) {
                case 'all':
                    message = `Mostrando todos os dados dispon√≠veis (${availableRange.firstDate.toLocaleDateString('pt-BR')} - ${lastDate.toLocaleDateString('pt-BR')})`;
                    break;
                case 'ytd':
                    const ytdStart = new Date(lastDate.getFullYear(), 0, 1);
                    message = `Dados de ${ytdStart.toLocaleDateString('pt-BR')} at√© ${lastDate.toLocaleDateString('pt-BR')}`;
                    break;
                case '1y':
                    const oneYearStart = new Date(lastDate);
                    oneYearStart.setFullYear(lastDate.getFullYear() - 1);
                    message = `Dados de ${oneYearStart.toLocaleDateString('pt-BR')} at√© ${lastDate.toLocaleDateString('pt-BR')}`;
                    break;
                case '3y':
                    const threeYearStart = new Date(lastDate);
                    threeYearStart.setFullYear(lastDate.getFullYear() - 3);
                    message = `Dados de ${threeYearStart.toLocaleDateString('pt-BR')} at√© ${lastDate.toLocaleDateString('pt-BR')}`;
                    break;
                case 'custom':
                    if (customStartDate && customEndDate) {
                        const start = new Date(customStartDate);
                        const end = new Date(customEndDate);
                        message = `Per√≠odo personalizado: ${start.toLocaleDateString('pt-BR')} - ${end.toLocaleDateString('pt-BR')}`;
                    }
                    break;
            }
            
            if (message) {
                console.log('üìä Filtro aplicado:', message);
            }
        }

    function fetchAndParseCSV(marketType, callback) {
        console.log('Iniciando fetchAndParseCSV...');
        // Apenas carrega dados para o Ibovespa, j√° que o filtro foi removido
        if (marketType !== 'ibov') {
             console.log('Tentativa de carregar mercado diferente de Ibovespa ignorada.');
             return;
        }
        const filePath = 'data/market-tracker.csv'; // Caminho fixo para o Ibovespa
        console.log('Tentando carregar arquivo:', filePath);
        Papa.parse(filePath, {
            download: true,
            header: true,
            complete: function(results) {
                console.log('CSV carregado com sucesso. N√∫mero de linhas:', results.data.length);
                csvData = results.data;
                if (callback) callback();
                updateFromPeriod();
                drawSelectedPeriodChart();
                // Carregar e exibir o gr√°fico do √≠ndice do Ibovespa
                fetchAndParseIndexCSV('ibov', () => {
                    updateLastUpdateLabel();
                });
            },
            error: function(err) {
                console.error('Erro ao carregar CSV:', err);
                alert(`Erro ao carregar o CSV do Mercado Brasileiro: ${err}`);
            }
        });
    }

    function updateIndicator(value, mediaValue) {
        const progressBar = document.getElementById('progressBar');
        const indicator = document.getElementById('indicator');
        const indicatorCircle = document.getElementById('indicatorCircle');
        const indicatorCircleMedia = document.getElementById('indicatorCircleMedia');
        const statusDescription = document.getElementById('statusDescription');
        const percentage = Math.min(100, Math.max(0, value));
        progressBar.style.width = `100%`;
        // --- NOVO: Definir limites das faixas conforme per√≠odo selecionado ---
        const periodValue = document.getElementById('periodSelect').value;
        let greenLimit, redLimit;
        if (periodValue === '21') {
            greenLimit = 15;
            redLimit = 85;
        } else {
            greenLimit = 20;
            redLimit = 80;
        }
        // Gradiente din√¢mico para a barra
        progressBar.style.background = `linear-gradient(to right,
            #E53935 0%, #E53935 10%,
            #FF9800 10%, #FF9800 ${greenLimit}%,
            #FFEB3B ${greenLimit}%, #FFEB3B ${redLimit}%,
            #4CAF50 ${redLimit}%, #4CAF50 ${redLimit+10}%,
            #8BC34A ${redLimit+10}%, #8BC34A 100%)`;
        function alignIndicatorElements() {
            const progressBarElem = progressBar.parentElement;
            const barRect = progressBarElem.getBoundingClientRect();
            const barWidth = barRect.width;
            const circleWidth = 70;
            const indicatorWidth = 3;
            const centerPx = (barWidth * (percentage / 100));
            indicator.style.left = `${centerPx - (indicatorWidth / 2)}px`;
            indicator.style.zIndex = '1';
            indicatorCircle.style.left = `${centerPx - (circleWidth / 2)}px`;
            indicatorCircle.style.zIndex = '2';
            // Bolinha da m√©dia
            if (indicatorCircleMedia && typeof mediaValue === 'number') {
                const mediaPx = (barWidth * (mediaValue / 100));
                indicatorCircleMedia.style.left = `${mediaPx - 35}px`;
                indicatorCircleMedia.innerHTML = `<div style=\"font-size: 28px; font-weight: 700; color: #888;\">${Math.round(mediaValue)}</div>`;
            }
        }
        alignIndicatorElements();
        window.addEventListener('resize', alignIndicatorElements);
        let status, color, description;
        if (percentage >= 0 && percentage < 10) {
            status = "Sobrevenda Extrema";
            color = '#E53935';
            description = "O mercado est√° em estado de sobrevenda extrema, indicando uma poss√≠vel oportunidade de compra.";
        } else if (percentage >= 10 && percentage < 20) {
            status = "Sobrevenda";
            color = '#FF9800';
            description = "O mercado est√° em estado de sobrevenda, sugerindo cautela na tomada de decis√µes.";
        } else if (percentage >= 20 && percentage < 80) {
            status = "Neutro";
            color = '#FFEB3B';
            description = "O mercado est√° em um estado neutro, indicando equil√≠brio entre compradores e vendedores.";
        } else if (percentage >= 80 && percentage < 90) {
            status = "Sobrecompra";
            color = '#4CAF50';
            description = "O mercado est√° em estado de sobrecompra, indicando poss√≠vel excesso de otimismo.";
        } else if (percentage >= 90 && percentage <= 100) {
            status = "Sobrecompra Extrema";
            color = '#8BC34A';
            description = "O mercado est√° em estado de sobrecompra extrema, sugerindo cautela com poss√≠veis corre√ß√µes.";
        } else {
            status = "Indefinido";
            color = '#ccc';
            description = "Valor fora dos intervalos esperados.";
        }
        indicatorCircle.innerHTML = `<div style=\"font-size: 28px; font-weight: 700; color: ${color};\">${Math.round(percentage)}</div>`;
        indicatorCircle.style.border = `3px solid ${color}`;
        statusDescription.textContent = description;
        statusDescription.style.color = color;
        const labelRow = progressBar.parentElement.nextElementSibling;
        if (labelRow && labelRow.style) {
            labelRow.style.display = 'flex';
            labelRow.style.justifyContent = 'space-between';
            labelRow.style.marginTop = '10px';
        }
        const labels = labelRow ? labelRow.querySelectorAll('span') : [];
        if (labels.length === 5) {
            labels[0].style.position = 'absolute';
            labels[0].style.left = '5%';
            labels[0].style.transform = 'translateX(-50%)';
            labels[1].style.position = 'absolute';
            labels[1].style.left = '15%';
            labels[1].style.transform = 'translateX(-50%)';
            labels[2].style.position = 'absolute';
            labels[2].style.left = '50%';
            labels[2].style.transform = 'translateX(-50%)';
            labels[3].style.position = 'absolute';
            labels[3].style.left = '85%';
            labels[3].style.transform = 'translateX(-50%)';
            labels[4].style.position = 'absolute';
            labels[4].style.left = '95%';
            labels[4].style.transform = 'translateX(-50%)';
            labelRow.style.position = 'relative';
        }
    }

    function calculateMarketIndex(periodData) {
        if (!periodData || periodData.length === 0) return 50;
        const validValues = periodData.filter(v => !isNaN(parseFloat(v)));
        if (validValues.length === 0) return 50;
        const numericValues = validValues.map(v => parseFloat(v));
        const lastValue = numericValues[numericValues.length - 1];
        if (lastValue >= 0 && lastValue <= 100) {
            return lastValue;
        }
        const sum = numericValues.reduce((a, b) => a + b, 0);
        const avg = sum / numericValues.length;
        const squareDiffs = numericValues.map(value => Math.pow(value - avg, 2));
        const avgSquareDiff = squareDiffs.reduce((a, b) => a + b, 0) / squareDiffs.length;
        const stdDev = Math.sqrt(avgSquareDiff);
        const zScore = (lastValue - avg) / (stdDev || 1);
        const normalizedValue = 50 + (Math.max(-3, Math.min(3, zScore)) * (50/3));
        return normalizedValue;
    }

    function updateFromPeriod() {
        if (!csvData || csvData.length === 0) return;
        const periodColName = document.getElementById('periodSelect').value;
        const periodData = [];
        csvData.forEach((row) => {
            const yVal = row[periodColName];
            if (yVal !== undefined && yVal !== null && yVal !== "" && !isNaN(parseFloat(yVal))) {
                periodData.push(parseFloat(yVal));
            }
        });
        if (periodData.length === 0) {
            console.warn('Nenhum dado num√©rico encontrado para o per√≠odo selecionado.');
            return;
        }
        const marketIndex = calculateMarketIndex(periodData);
        // Calcular a m√©dia ponderada dos √∫ltimos valores dos quatro per√≠odos
        const periodos = [
            { periodo: "21", peso: 1 },
            { periodo: "62", peso: 2 },
            { periodo: "125", peso: 3 },
            { periodo: "252", peso: 4 }
        ];
        let somaPonderada = 0, somaPesos = 0;
        periodos.forEach(({ periodo, peso }) => {
            const data = [];
            csvData.forEach(row => {
                const yVal = row[periodo];
                if (yVal !== undefined && yVal !== null && yVal !== "" && !isNaN(parseFloat(yVal))) {
                    data.push(parseFloat(yVal));
                }
            });
            if (data.length > 0) {
                const ultimoValor = data[data.length - 1];
                somaPonderada += ultimoValor * peso;
                somaPesos += peso;
            }
        });
        const mediaPeriodos = somaPesos > 0 ? somaPonderada / somaPesos : null;
        updateIndicator(marketIndex, mediaPeriodos);
        
        // Atualizar o gr√°fico de evolu√ß√£o do mercado
        drawSelectedPeriodChart();
    }

    document.getElementById('periodSelect').addEventListener('change', updateFromPeriod);

    function drawSelectedPeriodChart() {
        if (isMobile()) return; // N√£o executar em dispositivos m√≥veis
        console.log('Iniciando drawSelectedPeriodChart...');
        if (!csvData) {
            console.error('csvData est√° vazio ou indefinido');
            return;
        }
        const periodColName = document.getElementById('periodSelect').value;
        console.log('Per√≠odo selecionado:', periodColName);
        
        // Aplicar filtro de data
        console.log('Filtro atual:', currentFilter, 'Start:', customStartDate, 'End:', customEndDate);
        const filteredData = filterDataByDate(csvData, currentFilter, customStartDate, customEndDate);
        console.log('Dados filtrados:', filteredData.length, 'de', csvData.length, 'registros');
        console.log('Primeiro item filtrado:', filteredData[0]);
        console.log('√öltimo item filtrado:', filteredData[filteredData.length - 1]);
        
        if (filteredData.length === 0) {
            console.warn('Nenhum dado dispon√≠vel para o per√≠odo selecionado');
            // Limpar o gr√°fico existente
            if (chartInstance) {
                chartInstance.destroy();
                chartInstance = null;
            }
            return;
        }
        
        const yValues = [];
        const xLabels = [];
        filteredData.forEach((row) => {
            const yVal = row[periodColName];
            const dateVal = row['Date'] || row['date'] || row['DATA'] || row['data'] || row['Data'];
            if (yVal !== undefined && yVal !== null && yVal !== "" && !isNaN(parseFloat(yVal))) {
                yValues.push(parseFloat(yVal));
                // Converter para formato brasileiro se necess√°rio
                let formattedDate = dateVal;
                if (/^\d{4}-\d{2}-\d{2}$/.test(dateVal)) {
                    const [yyyy, mm, dd] = dateVal.split('-');
                    formattedDate = `${dd}/${mm}/${yyyy}`;
                } else if (/^\d{1,2}\/\d{1,2}\/\d{4}$/.test(dateVal)) {
                    const [mm, dd, yyyy] = dateVal.split('/');
                    formattedDate = `${dd.padStart(2, '0')}/${mm.padStart(2, '0')}/${yyyy}`;
                }
                xLabels.push(formattedDate ? formattedDate : '');
            }
        });
        console.log('Dados processados:', { xLabels: xLabels.length, yValues: yValues.length });
        if (yValues.length === 0) {
            console.warn('Nenhum dado num√©rico v√°lido encontrado para o per√≠odo selecionado');
            // Tentar usar todos os dados se o filtro n√£o retornar nada v√°lido
            console.log('Revertendo para todos os dados...');
            csvData.forEach((row) => {
                const yVal = row[periodColName];
                const dateVal = row['Date'] || row['date'] || row['DATA'] || row['data'] || row['Data'];
                if (yVal !== undefined && yVal !== null && yVal !== "" && !isNaN(parseFloat(yVal))) {
                    yValues.push(parseFloat(yVal));
                    let formattedDate = dateVal;
                    if (/^\d{4}-\d{2}-\d{2}$/.test(dateVal)) {
                        const [yyyy, mm, dd] = dateVal.split('-');
                        formattedDate = `${dd}/${mm}/${yyyy}`;
                    } else if (/^\d{1,2}\/\d{1,2}\/\d{4}$/.test(dateVal)) {
                        const [mm, dd, yyyy] = dateVal.split('/');
                        formattedDate = `${dd.padStart(2, '0')}/${mm.padStart(2, '0')}/${yyyy}`;
                    }
                    xLabels.push(formattedDate ? formattedDate : '');
                }
            });
            
            if (yValues.length === 0) {
                console.error('Nenhum dado num√©rico encontrado para o per√≠odo:', periodColName);
                alert(`Nenhum dado num√©rico encontrado para o per√≠odo "${periodColName}".`);
                return;
            }
        }
        createOrUpdateChart('chartPeriod', '', xLabels, yValues);
    }
    
    function createOrUpdateChart(canvasId, seriesName, xLabels, yValues) {
        const ctx = document.getElementById(canvasId).getContext('2d');
        // Destruir gr√°fico existente se houver
        if (canvasId === 'chartPeriod' && chartInstance) {
            console.log('Destruindo gr√°fico existente...');
            chartInstance.destroy();
            chartInstance = null;
        } else if (canvasId === 'chartIndex' && indexChartInstance) {
            console.log('Destruindo gr√°fico de √≠ndice existente...');
            indexChartInstance.destroy();
            indexChartInstance = null;
        }
        
        // Gradiente para a linha
        const gradientLine = ctx.createLinearGradient(0, 0, ctx.canvas.width, 0);
        gradientLine.addColorStop(0, 'rgba(0, 122, 255, 1)');
        gradientLine.addColorStop(1, 'rgba(0, 180, 216, 1)');
        
        // Calcular os √≠ndices do primeiro ponto de cada ano
        const primeirosAnos = {};
        xLabels.forEach((label, i) => {
            if (typeof label === 'string' && label.includes('/')) {
                const [,, year] = label.split('/');
                if (!(year in primeirosAnos)) {
                    primeirosAnos[year] = i;
                }
            }
        });
        
        const chartData = {
            labels: xLabels,
            datasets: [{
                label: '',
                data: yValues,
                fill: false,
                borderColor: gradientLine,
                borderWidth: 2,
                pointRadius: 0,
                pointHoverRadius: 6,
                tension: 0.35,
                z: 10
            }]
        };
        
        const options = {
            responsive: true,
            maintainAspectRatio: false,
            animation: {
                duration: 1200,
                easing: 'easeOutQuart'
            },
            scales: {
                y: Object.assign(
                    {
                        beginAtZero: false,
                        grid: { display: false, drawBorder: false },
                        ticks: { color: '#666', font: { family: 'Poppins', size: 12 } }
                    },
                    canvasId === 'chartPeriod' ? { min: 0, max: 100 } : {}
                ),
                x: {
                    grid: { display: false, drawBorder: false },
                    ticks: {
                        color: '#666',
                        font: { family: 'Poppins', size: 11 },
                        autoSkip: false,
                        callback: function(value, index, values) {
                            try {
                                const label = this.getLabelForValue(value);
                                if (typeof label === 'string' && label.includes('/')) {
                                    const [,, year] = label.split('/');
                                    if (primeirosAnos[year] === index) {
                                        return year;
                                    }
                                }
                                return '';
                            } catch (error) {
                                console.error('Erro ao processar tick:', error);
                                return '';
                            }
                        }
                    }
                }
            },
            plugins: {
                legend: {
                    display: false,
                },
                tooltip: {
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',
                    borderColor: 'rgba(33, 150, 243, 0.8)',
                    borderWidth: 1,
                    titleColor: '#333',
                    bodyColor: '#666',
                    bodyFont: { family: 'Poppins', size: 13 },
                    padding: 10,
                    cornerRadius: 6
                }
            }
        };
        
        // Criar o gr√°fico
        chartInstance = new Chart(ctx, {
            type: 'line',
            data: chartData,
            options: options,
            plugins: [{
                id: 'backgroundZones',
                beforeDraw: function(chart) {
                    if (!chart.chartArea) {
                        return;
                    }
                    const { ctx, chartArea, scales } = chart;
                    const { top, bottom, left, right } = chartArea;
                    
                    // Desenha o logo como fundo
                    // Primeiro limpa o fundo
                    ctx.save();
                    ctx.fillStyle = 'white';
                    ctx.fillRect(left, top, right - left, bottom - top);
                    
                    // Desenha o logo com opacidade reduzida
                    ctx.globalAlpha = 0.2; // Ajuste a opacidade conforme necess√°rio
                    
                    // Calcula as dimens√µes para manter a propor√ß√£o e centralizar
                    const logoRatio = logoImage.width / logoImage.height;
                    let logoWidth = right - left - 30; // Um pouco menor que a √°rea do gr√°fico
                    let logoHeight = logoWidth / logoRatio;
                    
                    // Se for muito alto, ajusta baseado na altura
                    if (logoHeight > (bottom - top - 10)) {
                        logoHeight = bottom - top - 10;
                        logoWidth = logoHeight * logoRatio;
                    }
                    
                    // Centraliza o logo
                    const logoX = left + ((right - left) - logoWidth) / 2;
                    const logoY = top + ((bottom - top) - logoHeight) / 2;
                    
                    ctx.drawImage(logoImage, logoX, logoY, logoWidth, logoHeight);
                    ctx.globalAlpha = 1.0;
                    
                    // Calcular posi√ß√£o dos valores 0, greenLimit, redLimit e 100 no eixo Y
                    const periodValue = document.getElementById('periodSelect').value;
                    let greenLimit, redLimit;
                    if (periodValue === '21') {
                        greenLimit = 15;
                        redLimit = 85;
                    } else {
                        greenLimit = 20;
                        redLimit = 80;
                    }
                    const y0 = scales.y.getPixelForValue(0);
                    const yGreen = scales.y.getPixelForValue(greenLimit);
                    const yRed = scales.y.getPixelForValue(redLimit);
                    const y100 = scales.y.getPixelForValue(100);
                    
                    // Faixa verde (0 at√© greenLimit)
                    const yBase = scales.y.getPixelForValue(0);
                    const greenTop = Math.min(yBase, yGreen);
                    const greenHeight = Math.abs(yBase - yGreen);
                    ctx.fillStyle = 'rgba(75, 192, 75, 0.18)';
                    ctx.fillRect(left, greenTop, right - left, greenHeight);
                    ctx.strokeStyle = 'rgba(75, 192, 75, 0.35)';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(left, greenTop, right - left, greenHeight);
                    
                    // Faixa vermelha (redLimit at√© 100)
                    const redTop = Math.min(yRed, y100);
                    const redHeight = Math.abs(yRed - y100);
                    ctx.fillStyle = 'rgba(255, 99, 132, 0.18)';
                    ctx.fillRect(left, redTop, right - left, redHeight);
                    ctx.strokeStyle = 'rgba(255, 99, 132, 0.35)';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(left, redTop, right - left, redHeight);
                    
                    // Linhas de demarca√ß√£o
                    ctx.strokeStyle = 'rgba(75, 192, 75, 0.6)';
                    ctx.beginPath();
                    ctx.moveTo(left, yGreen);
                    ctx.lineTo(right, yGreen);
                    ctx.stroke();
                    ctx.strokeStyle = 'rgba(255, 99, 132, 0.6)';
                    ctx.beginPath();
                    ctx.moveTo(left, yRed);
                    ctx.lineTo(right, yRed);
                    ctx.stroke();
                    
                    ctx.restore();
                }
            }]
        });
        
        return chartInstance;
    }
    
    // Carrega o logo primeiro e depois o CSV
    logoImage.onload = function() {
        console.log('Logo carregado com sucesso');
        fetchAndParseCSV('ibov', () => {
            console.log('Callback ap√≥s carregar CSV');
            drawSelectedPeriodChart();
        });
    };
    
    logoImage.onerror = function() {
        console.error("Erro ao carregar o logo. Continuando sem o logo.");
        fetchAndParseCSV('ibov', () => {
            console.log('Callback ap√≥s carregar CSV (sem logo)');
            drawSelectedPeriodChart();
        });
    };
    </script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM carregado, iniciando aplica√ß√£o...');
            // Inicializar filtros
            initializeFilterListeners();
            // Inicializar com o Ibovespa
            fetchAndParseCSV('ibov', () => {
                console.log('Inicializa√ß√£o completa');
                // Garantir que o filtro "YTD" esteja ativo inicialmente
                console.log('Filtro inicial:', currentFilter);
                // Criar gr√°fico mobile se for dispositivo m√≥vel
                createMobileChart();
            });
            
            // Evento para mudan√ßa de per√≠odo mobile
            const periodSelectMobile = document.getElementById('periodSelectMobile');
            if (periodSelectMobile) {
                periodSelectMobile.addEventListener('change', function() {
                    createMobileChart();
                });
            }
        });
    </script>
    <script>
        // Remover o segundo card duplicado de 'Momento de Mercado' (ap√≥s o gr√°fico de evolu√ß√£o)
        const allCards = document.querySelectorAll('.card');
        if (allCards.length > 1) {
            const lastCard = allCards[allCards.length - 1];
            if (lastCard.querySelector('h2') && lastCard.querySelector('h2').textContent.includes('Momento de Mercado')) {
                lastCard.remove();
            }
        }
    </script>
    <script>
    // indexChartInstance j√° foi declarado acima

    function fetchAndParseIndexCSV(indexType, callback) {
        // Apenas carrega dados para o Ibovespa
        if (indexType !== 'ibov') {
             console.log('Tentativa de carregar √≠ndice diferente de Ibovespa ignorada.');
             // Limpar ou esconder o gr√°fico existente se houver (embora n√£o devesse ser chamado para outros tipos)
            if (indexChartInstance) {
                indexChartInstance.destroy();
                indexChartInstance = null;
            }
             if (callback) callback();
             return;
        }

        const filePath = 'data/ibov.csv'; // Caminho fixo para o Ibovespa
        Papa.parse(filePath, {
            download: true,
            header: true,
            complete: function(results) {
                ibovData = results.data; // Armazenar dados originais
                drawIndexChart(ibovData, indexType); // indexType ser√° 'ibov'
                 if (callback) callback();
            },
            error: function(err) {
                alert(`Erro ao carregar o CSV do Ibovespa: ${err}`);
            }
        });
    }

    function drawIndexChart(indexData, indexType) {
        const ctx = document.getElementById('chartIndex').getContext('2d');
        if (indexChartInstance) {
            indexChartInstance.destroy();
            indexChartInstance = null;
        }

        // Aplicar filtro de data para o Ibovespa
        const filteredIndexData = filterDataByDate(indexData, currentFilterIbov, customStartDateIbov, customEndDateIbov);
        console.log('Dados do Ibovespa filtrados:', filteredIndexData.length, 'de', indexData.length, 'registros');

        const xLabels = [];
        const yValues = [];
        const medias = [];
        const mediasPonderadas = [];

        // --- Calcular m√©dias simples e ponderadas do arquivo ibov.csv ---
        filteredIndexData.forEach(row => {
            const date = row['date'] || row['Date'] || row['DATA'] || row['data'] || row['Data'];
            if (!date) return;
            
            let month, day, year, formattedDate;
            if (date.includes('-')) {
                // Formato YYYY-MM-DD
                [year, month, day] = date.split('-');
                formattedDate = `${day.padStart(2, '0')}/${month.padStart(2, '0')}/${year}`;
            } else if (date.includes('/')) {
                // Formato MM/DD/YYYY
                [month, day, year] = date.split('/');
                formattedDate = `${day.padStart(2, '0')}/${month.padStart(2, '0')}/${year}`;
            } else {
                return;
            }
            const media21 = parseFloat(row['21']) || 0;
            const media62 = parseFloat(row['62']) || 0;
            const media125 = parseFloat(row['125']) || 0;
            const media252 = parseFloat(row['252']) || 0;
            const mediaSimples = (media21 + media62 + media125 + media252) / 4;
            const somaPonderada = media21 * 1 + media62 * 2 + media125 * 3 + media252 * 4;
            const somaPesos = 1 + 2 + 3 + 4;
            const mediaPonderada = somaPesos > 0 ? somaPonderada / somaPesos : 0;
            medias.push({ date: formattedDate, media: mediaSimples });
            mediasPonderadas.push({ date: formattedDate, media: mediaPonderada });
        });

        // Processar os dados do Ibovespa
        filteredIndexData.forEach(row => {
            const date = row['date'] || row['Date'] || row['DATA'] || row['data'] || row['Data'];
            const value = row['Valor'] || row['valor'] || row['VALUE'] || row['value'];
            if (date && value && !isNaN(parseFloat(value))) {
                let month, day, year, formattedDate;
                if (date.includes('-')) {
                    // Formato YYYY-MM-DD
                    [year, month, day] = date.split('-');
                    formattedDate = `${day.padStart(2, '0')}/${month.padStart(2, '0')}/${year}`;
                } else if (date.includes('/')) {
                    // Formato MM/DD/YYYY
                    [month, day, year] = date.split('/');
                    formattedDate = `${day.padStart(2, '0')}/${month.padStart(2, '0')}/${year}`;
                } else {
                    return;
                }
                xLabels.push(formattedDate);
                yValues.push(parseFloat(value));
            }
        });

        // Pontos verdes: regi√µes consecutivas com m√©dia simples <= 20 (menor valor)
        let pontosVerdesArray = yValues.map(() => null);
        let i = 0;
        while (i < xLabels.length) {
            const mediaObj = medias.find(m => m.date === xLabels[i]);
            if (mediaObj && mediaObj.media <= 20) {
                let minIdx = i;
                let minValue = yValues[i];
                let j = i + 1;
                while (j < xLabels.length) {
                    const nextMediaObj = medias.find(m => m.date === xLabels[j]);
                    if (!nextMediaObj || nextMediaObj.media > 20) break;
                    if (yValues[j] < minValue) {
                        minValue = yValues[j];
                        minIdx = j;
                    }
                    j++;
                }
                pontosVerdesArray[minIdx] = yValues[minIdx];
                i = j;
            } else {
                i++;
            }
        }

        // Pontos vermelhos: regi√µes consecutivas com m√©dia ponderada >= 80 (maior valor)
        let pontosVermelhosArray = yValues.map(() => null);
        i = 0;
        while (i < xLabels.length) {
            const mediaObj = mediasPonderadas.find(m => m.date === xLabels[i]);
            if (mediaObj && mediaObj.media >= 80) {
                let maxIdx = i;
                let maxValue = yValues[i];
                let j = i + 1;
                while (j < xLabels.length) {
                    const nextMediaObj = mediasPonderadas.find(m => m.date === xLabels[j]);
                    if (!nextMediaObj || nextMediaObj.media < 80) break;
                    if (yValues[j] > maxValue) {
                        maxValue = yValues[j];
                        maxIdx = j;
                    }
                    j++;
                }
                pontosVermelhosArray[maxIdx] = yValues[maxIdx];
                i = j;
            } else {
                i++;
            }
        }

        // Calcular os √≠ndices do primeiro ponto de cada ano
        const primeirosAnos = {};
        xLabels.forEach((label, idx) => {
            if (typeof label === 'string' && label.includes('/')) {
                const [,, year] = label.split('/');
                if (!(year in primeirosAnos)) {
                    primeirosAnos[year] = idx;
                }
            }
        });

        const gradientLine = ctx.createLinearGradient(0, 0, ctx.canvas.width, 0);
        gradientLine.addColorStop(0, 'rgba(0, 122, 255, 1)');
        gradientLine.addColorStop(1, 'rgba(0, 180, 216, 1)');

        const chartData = {
            labels: xLabels,
            datasets: [
                {
                    label: indexType === 'ibov' ? 'Ibovespa' : 'S&P 500',
                    data: yValues,
                    fill: false,
                    borderColor: gradientLine,
                    borderWidth: 2,
                    pointRadius: 0,
                    pointHoverRadius: 6,
                    tension: 0.35
                },
                {
                    label: 'M√©dia <= 20 (Momento de Mercado)',
                    data: pontosVerdesArray,
                    type: 'scatter',
                    showLine: false,
                    pointRadius: 8,
                    pointBackgroundColor: 'rgba(0, 200, 83, 0.95)',
                    pointBorderColor: '#fff',
                    pointBorderWidth: 2,
                    order: 2,
                    z: 100,
                    hoverBackgroundColor: 'rgba(0, 200, 83, 1)',
                    hoverBorderColor: '#333',
                    hoverBorderWidth: 2
                },
                {
                    label: 'M√©dia Ponderada >= 80 (Momento de Mercado)',
                    data: pontosVermelhosArray,
                    type: 'scatter',
                    showLine: false,
                    pointRadius: 8,
                    pointBackgroundColor: 'rgba(255, 99, 132, 0.95)',
                    pointBorderColor: '#fff',
                    pointBorderWidth: 2,
                    order: 2,
                    z: 100,
                    hoverBackgroundColor: 'rgba(255, 99, 132, 1)',
                    hoverBorderColor: '#333',
                    hoverBorderWidth: 2
                }
            ]
        };

        const options = {
            responsive: true,
            maintainAspectRatio: false,
            animation: {
                duration: 1200,
                easing: 'easeOutQuart'
            },
            scales: {
                y: {
                    beginAtZero: false,
                    grid: { display: false, drawBorder: false },
                    ticks: { color: '#666', font: { family: 'Poppins', size: 12 } }
                },
                x: {
                    grid: { display: false, drawBorder: false },
                    ticks: {
                        color: '#666',
                        font: { family: 'Poppins', size: 11 },
                        autoSkip: false,
                        callback: function(value, index, values) {
                            try {
                                const label = this.getLabelForValue(value);
                                if (typeof label === 'string' && label.includes('/')) {
                                    const [,, year] = label.split('/');
                                    if (primeirosAnos[year] === index) {
                                        return year;
                                    }
                                }
                                return '';
                            } catch (error) {
                                console.error('Erro ao processar tick:', error);
                                return '';
                            }
                        }
                    }
                }
            },
            plugins: {
                legend: { display: false },
                tooltip: {
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',
                    borderColor: 'rgba(33, 150, 243, 0.8)',
                    borderWidth: 1,
                    titleColor: '#333',
                    bodyColor: '#666',
                    bodyFont: { family: 'Poppins', size: 13 },
                    padding: 10,
                    cornerRadius: 6,
                    callbacks: {
                        label: function(context) {
                            // Pontos verdes
                            if (context.dataset.label && context.dataset.label.includes('M√©dia <= 20')) {
                                const valor = context.parsed.y;
                                return [
                                    'Ponto de compra indicado pelo rastreador de mercado, m√©dia <= 20',
                                    `Valor do Ibovespa: ${valor.toLocaleString('pt-BR')}`
                                ];
                            }
                            // Pontos vermelhos
                            if (context.dataset.label && context.dataset.label.includes('M√©dia Ponderada >= 80')) {
                                const valor = context.parsed.y;
                                return [
                                    'Ponto de cautela ou poss√≠vel venda indicado pelo rastreador de mercado, m√©dia ponderada >= 80',
                                    `Valor do Ibovespa: ${valor.toLocaleString('pt-BR')}`
                                ];
                            }
                            // Para o dataset principal (Ibovespa), n√£o mostrar nada
                            return '';
                        }
                    }
                },
                id: 'backgroundLogoIndex',
                beforeDraw: function(chart) {
                    if (!chart.chartArea) return;
                    const { ctx, chartArea } = chart;
                    const { left, right, top, bottom } = chartArea;

                    ctx.save();
                    ctx.globalAlpha = 0.13;
                    const logoRatio = logoImage.width / logoImage.height;
                    let logoWidth = right - left - 30;
                    let logoHeight = logoWidth / logoRatio;
                    if (logoHeight > (bottom - top - 10)) {
                        logoHeight = bottom - top - 10;
                        logoWidth = logoHeight * logoRatio;
                    }
                    const logoX = left + ((right - left) - logoWidth) / 2;
                    const logoY = top + ((bottom - top) - logoHeight) / 2;
                    ctx.drawImage(logoImage, logoX, logoY, logoWidth, logoHeight);
                    ctx.globalAlpha = 1.0;
                    ctx.restore();
                }
            }
        };

        indexChartInstance = new Chart(ctx, {
            type: 'line',
            data: chartData,
            options: options
        });

        document.getElementById('indexTitle').textContent = indexType === 'ibov' ? ' Ibovespa' : ' S&P 500';
    }

    function updateLastUpdateLabel() {
        const label = document.getElementById('lastUpdateLabelIndex');
        if (label) {
            const now = new Date();
            now.setDate(now.getDate() - 1); // Subtrai um dia
            const dia = String(now.getDate()).padStart(2, '0');
            const mes = String(now.getMonth() + 1).padStart(2, '0');
            const ano = now.getFullYear();
            label.textContent = `Atualizado pela √∫ltima vez em: ${dia}/${mes}/${ano}`;
        }
    }
    </script>
    <script>
    (function() {
        // Momento de Mercado
        const labelMomento = document.getElementById('lastUpdateLabelMomento');
        if (labelMomento) {
            const now = new Date();
            now.setDate(now.getDate() - 1); // Subtrai um dia
            const dia = String(now.getDate()).padStart(2, '0');
            const mes = String(now.getMonth() + 1).padStart(2, '0');
            const ano = now.getFullYear();
            labelMomento.textContent = `Atualizado pela √∫ltima vez em: ${dia}/${mes}/${ano}`;
        }
        // Evolu√ß√£o do Mercado
        const labelMercado = document.getElementById('lastUpdateLabel');
        if (labelMercado) {
            const now = new Date();
            now.setDate(now.getDate() - 1); // Subtrai um dia
            const dia = String(now.getDate()).padStart(2, '0');
            const mes = String(now.getMonth() + 1).padStart(2, '0');
            const ano = now.getFullYear();
            labelMercado.textContent = `Atualizado pela √∫ltima vez em: ${dia}/${mes}/${ano}`;
        }
    })();
    </script>
</body>
</html>
